# Eureka



## 简介



### Spring-Cloud Euraka介绍



Spring-Cloud Euraka是Spring Cloud集合中一个组件，它是对Euraka的集成，用于服务注册和发现。Eureka是Netflix中的一个开源框架。它和 zookeeper、Consul一样，都是用于服务注册管理的，同样，Spring-Cloud 还集成了Zookeeper和Consul。

在项目中使用Spring Cloud Euraka的原因是**它可以利用Spring Cloud Netfilix中其他的组件，如zull等，因为Euraka是属于Netfilix的。**



### Euraka介绍



Eureka由多个instance(服务实例)组成，这些服务实例可以分为两种：Eureka Server和Eureka Client。为了便于理解，我们将Eureka client再分为Service Provider和Service Consumer。

- Eureka Server 提供服务注册和发现
- Service Provider 服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到
- Service Consumer服务消费方，从Eureka获取注册服务列表，从而能够消费服务



### Eureka Server和Eureka Client



Eureka包含两个组件：

+ **Eureka Server提供服务注册服务**

各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。

+ **EurekaClient通过注册中心进行访问**

是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）



### 服务架构



<img src="./images/image-1647921542306.png" alt="image-1647921542306.png" style="zoom:60%;" />





- **服务注册（Register）**：通过REST请求的方式把自身的元数据（ip、端口、运行状态指标url、主页地址等）注册到Eureka Server。
- **服务续约（Renew）**：服务注册后，Eureka Client会维护一个形态来持续通知Eureka Server，说明服务一直处于可用状态，防止被剔除（每30秒发送一次，如果90秒还未发送心跳，表好宕机）。
- **服务同步（Replicate）**：Eureka Server之间会互相进行注册，构建Eureka Server集群，不同Eureka Server之间会进行服务同步，用来不保证服务信息的一致性。
- **获取服务（Get Registry）**：服务消费者在启动的时候，会发送一个REST请求给Eureka Server，获取上面注册的服务清单，并且缓存在Eureka Client本地，默认缓存30秒。同时为了性能考虑，Eureka Server也会维护一份只读的服务缓存，该缓存每隔30秒更新一次。
- **服务调用（Make Remote Call）**：服务消费者在获取到服务清单后，就可以根据清单中的服务列表信息，查找到其他服务的地址，从而进行远程调用。Eureka有Region和Zone的概念，一个Region可以包含多个Zone，在进行服务调用时，优先访问处于同一个Zone中的服务提供者。
- **服务下线（Cancel）**：当Eureka Client需要关闭或重启是，就不希望这个时间段内再有请求进来，所以需要提前发送REST请求给Eureka Server，Eureka Server收到请求后，就会把该服务设置为下线（DOWN），并把该下线事件传播出去。
- **服务剔除（Evict）**：有时候，服务实例可能会因为网络故障等原因导致不能提供服务，而此时实例也没有发送请求给Eureka Server进行服务下线。所以还需要有服务剔除机制，Eureka Server在启动的时候会创建一个定时任务，每个一段时间（默认60s），从当前服务清单中把超时没有续约（默认90s，由于bug，实际180s）的服务剔除。



## pom文件



+ 以前的老版本（当前使用2018）

```java
<dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>
```



+ 现在新版本（当前使用2020.2）

```java
<!--eureka服务端-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
<!--eureka客户端-->    
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>    
```



## 父工程-cloud-eureka



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>spring-cloud</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>pom</packaging>
    <modules>
        <module>cloud-eureka-server7001</module>
    </modules>
    <artifactId>cloud-eureka</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>
</project>
```



## 服务端-cloud-eureka-server7001



### pom



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-eureka</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>cloud-eureka-server7001</artifactId>
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
</project>
```



### 启动类



```java
package com.it;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * 描述 ：EurekaServer7001
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableEurekaServer
@SpringBootApplication
public class EurekaServer7001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServer7001.class,args);
    }
}
```



### yaml配置



```yaml
server:
  port: 7001

spring:
  application:
    name: eureka-server-7001
eureka:
  instance:
    hostname: 127.0.0.1
  client:
    register-with-eureka: false #不需要王eureka注册中心中注册自己
    fetch-registry: false   #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
```





### 测试



http://localhost:7001/

<img src="./images/image-20220319114602443.png" alt="image-20220319114602443" style="zoom:67%;" />





## 支付服务提供者注册Eureka



### eureka-provider-payment8001



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-provider</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>eureka-provider-payment8001</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--热部署插件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```



### 复制代码



复制 `demo-provider-payment8001`里面的代码和配置文件到 `eureka-provider-payment8001`

修改启动类名字：`EurekaPaymentAPP8001`

<img src="./images/image-20220319120251381.png" alt="image-20220319120251381" style="zoom:80%;" />

### application.yaml



```yaml
server:
  port: 8001

spring:
  application:
    name: eureka-payment-service
  datasource:
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/test?useSSL=false&allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8
  boot:
    admin:
      client:
        url: http://localhost:5555
        instance:
          prefer-ip: true
#开放端点用于SpringBoot Admin的监控
management:
  endpoints:
    web:
      exposure:
        include: '*'

logging:
  file:
    name: admin-client.log  #配置生成日志文件名称
mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.it.common.entity    # 所有Entity别名类所在包

# eureka 的配置
eureka:
  instance:
    hostname: 127.0.0.1
  client:
    fetch-registry: true  #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    register-with-eureka: true #向eureka服务注册中心中注册自己
    service-url:
      defaultZone: http://localhost:7001/eureka
```



### 启动类



```java
@EnableEurekaClient  //添加eureka客户端的注解
@SpringBootApplication
public class EurekaPaymentAPP8001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaPaymentAPP8001.class, args);
    }
}
```





### 测试



访问： http://localhost:7001/

<img src="./images/image-20220319121023422.png" alt="image-20220319121023422" style="zoom:67%;" />





## 支付服务消费者注册Eureka



### eureka-consumer-order80



```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-consumer</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>eureka-consumer-order80</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--热部署插件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```



### 复制代码



复制 `demo-consumer-order80`里面的代码和配置文件到 `eureka-consumer-order80`

修改启动类名字：`EurekaOrderAPP80`

<img src="./images/image-20220319132245817.png" alt="image-20220319132245817" style="zoom:80%;" />



### applcation.yaml



```java
server:
  port: 80

eureka:
  instance:
    hostname: 127.0.0.1
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:7001/eureka
spring:
  application:
    name: eureka-consumer-order
```



### 启动类



```java
package com.it;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

/**
 * 描述 ：
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableEurekaClient
@SpringBootApplication
public class EurekaOrderAPP80 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaOrderAPP80.class, args);
    }
}
```



### 测试



http://localhost:7001/

<img src="./images/image-20220319132352147.png" alt="image-20220319132352147" style="zoom:80%;" />





## 服务发现Discovery



### 简介



对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息



### 添加Controller



```java
    @GetMapping(value = "/payment/discovery")
    public Object discovery()
    {
        List<String> services = discoveryClient.getServices();
        for (String element : services) {
            System.out.println(element);
        }

        List<ServiceInstance> instances = discoveryClient.getInstances("EUREKA-PAYMENT-SERVICE");
        for (ServiceInstance element : instances) {
            System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t"
                    + element.getUri());
        }
        return this.discoveryClient;
    }
```



### 启动类



添加： @EnableDiscoveryClient //服务注册与发现



### 测试



请求：http://localhost:8001/payment/discovery

<img src="./images/image-20220319133145838.png" alt="image-20220319133145838" style="zoom:80%;" />



## 自我保护



### 现象



我们过一段时间去看eureka的页面，会发现：

保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，
Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。

如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：
**EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT.** 
**RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE**

<img src="./images/image-20220319134627956.png" alt="image-20220319134627956" style="zoom:80%;" />



### GitHub上的简介



Eureka 客户端尝试与同一区域中的 Eureka Server 通信。如果与服务器通信时出现问题，或者如果服务器不在同一区域中，则客户端将故障转移到其他区域中的服务器。

一旦服务器开始接收流量，在服务器上执行的所有[操作](https://github.com/Netflix/eureka/wiki/Understanding-eureka-client-server-communication)都会复制到服务器知道的所有对等节点。如果某项操作由于某种原因失败，则该信息将在下一个心跳信号中进行协调，该心跳信号也会在服务器之间复制。

当 Eureka 服务器启动时，它会尝试从相邻节点获取所有实例注册信息。如果从节点获取信息时出现问题，服务器会在放弃之前尝试所有对等方。如果服务器能够成功获取所有实例，它会根据该信息设置它应该接收的续订阈值。如果任何时候续订低于为该值配置的百分比（在 15 分钟内低于 85%），服务器将停止使实例过期以保护当前实例注册表信息。

在 Netflix 中，上述保护被称为**自我保护**模式，主要用于在一组客户端和 Eureka Server 之间存在网络分区的场景中作为保护。在这些情况下，服务器会尝试保护它已经拥有的信息。在大规模中断的情况下，可能会导致客户端获取不再存在的实例。客户端必须确保它们对 eureka 服务器返回不存在或无响应的实例具有弹性。在这些情况下最好的保护是快速超时并尝试其他服务器。

在服务器无法从相邻节点获取注册信息的情况下，它会等待几分钟（5 分钟），以便客户端可以注册他们的信息。服务器通过将流量仅倾斜到一组实例并导致容量问题来努力不向那里的客户端提供部分信息。



### 为什么会产生Eureka自我保护机制？



为了防止EurekaClient可以正常运行，但是 与 EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除



### 什么是自我保护模式？





如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，此时会触发Eureka Server进入保护模式，进入自我保护模式后，将会保护服务注册表中的信息，不再删除服务注册表中的数据。

Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。



<img src="./images/image-20220319134924025.png" alt="image-20220319134924025" style="zoom:80%;" />



**在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。**

它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着

**综上，自我保护模式是一种应对网络异常的安全保护措施**。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。**使用自我保护模式，可以让Eureka集群更加的健壮、稳定。**



### 一句话概述



一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存

属于CAP里面的AP分支



### 服务端禁止自我保护



在eureka服务端的application.yaml配置文件中加上

```yaml
eureka:
  server:
    enable-self-preservation: false #关闭自我保护机制，保证不可用服务被及时踢除
    eviction-interval-timer-in-ms: 2000
```



<img src="./images/image-20220319135731410.png" alt="image-20220319135731410" style="zoom:80%;" />





### 客户端禁止自我保护



```yaml
eureka:
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      # singleton version
      defaultZone: http://eureka7001.com:7001/eureka
#心跳检测与续约时间
#开发时设置小些，保证服务关闭后注册中心能即使剔除服务
  instance:
  #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)
    lease-renewal-interval-in-seconds: 1
  #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务
    lease-expiration-duration-in-seconds: 2
```



先启动7001再启动8001再关闭8001，马上就被删除了



## 查看服务实例信息



查看服务实例信息。格式如下

```java
/eureka/apps/{appName}
```



举例如下：



```java
http://localhost:7001/eureka/apps/EUREKA-PAYMENT-SERVICE
```



结果为：



```xml
<application>
    <name>EUREKA-PAYMENT-SERVICE</name>
    <instance>
        <instanceId>DESKTOP-81AEV1P:eureka-payment-service:8001</instanceId>
        <hostName>127.0.0.1</hostName>
        <app>EUREKA-PAYMENT-SERVICE</app>
        <ipAddr>10.0.84.74</ipAddr>
        <status>UP</status>
        <overriddenstatus>UNKNOWN</overriddenstatus>
        <port enabled="true">8001</port>
        <securePort enabled="false">443</securePort>
        <countryId>1</countryId>
        <dataCenterInfo class="com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo">
            <name>MyOwn</name>
        </dataCenterInfo>
        <leaseInfo>
            <renewalIntervalInSecs>30</renewalIntervalInSecs>
            <durationInSecs>90</durationInSecs>
            <registrationTimestamp>1647669463462</registrationTimestamp>
            <lastRenewalTimestamp>1647669733607</lastRenewalTimestamp>
            <evictionTimestamp>0</evictionTimestamp>
            <serviceUpTimestamp>1647669463462</serviceUpTimestamp>
        </leaseInfo>
        <metadata>
            <management.port>8001</management.port>
        </metadata>
        <homePageUrl>http://127.0.0.1:8001/</homePageUrl>
        <statusPageUrl>http://127.0.0.1:8001/actuator/info</statusPageUrl>
        <healthCheckUrl>http://127.0.0.1:8001/actuator/health</healthCheckUrl>
        <vipAddress>eureka-payment-service</vipAddress>
        <secureVipAddress>eureka-payment-service</secureVipAddress>
        <isCoordinatingDiscoveryServer>false</isCoordinatingDiscoveryServer>
        <lastUpdatedTimestamp>1647669463462</lastUpdatedTimestamp>
        <lastDirtyTimestamp>1647669463460</lastDirtyTimestamp>
        <actionType>ADDED</actionType>
    </instance>
</application>
```





## 优雅停服



我们已经禁止了eureka的自我保护机制，然后我们去关闭服务的话，就会迅速的从eureka里面剔除，但是我们可以使用更好的方式来进行那就是：`spring-boot-actuator`

+ 添加依赖



```java
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```



+ application.yml



```yaml
#开放端点用于SpringBoot Admin的监控
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    shutdown:
      enabled: true
```



+ postMan模拟测试

记得把eureka的自我保护机制打开，否则测试不出来效果：

```java
http://127.0.0.1:8001/actuator/shutdown
```

post方式请求，然后发现请求就停止了





## 集群搭建



### 简介



<img src="./images/image-20220319144317699.png" alt="image-20220319144317699" style="zoom:80%;" />

问题：微服务RPC远程服务调用最核心的是什么：**高可用**，

试想你的注册中心只有一个only one， 它出故障了那就呵呵(￣▽￣)"了，会导致整个为服务环境不可用，所以

解决办法：搭建Eureka注册中心集群 ，实现负载均衡+故障容错



### 配置host



打开自己电脑的`hosts`

window：`C:\Windows\System32\drivers\etc`

liunx: `/etc/hosts`



```shell
127.0.0.1		eureka1
127.0.0.1		eureka2
127.0.0.1		eureka3
```





### 创建模块





cloud-eureka-cluster-server7001

cloud-eureka-cluster-server7002

cloud-eureka-cluster-server7003

这三个模块的pom文件都是

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-eureka</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>这里写项目的名称</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

</project>
```



### 启动类



启动类一摸一样，只是文件名字类名不相同而已

| 项目名称                        | 启动类名称        |
| ------------------------------- | ----------------- |
| cloud-eureka-cluster-server7001 | EurekaCluster7001 |
| cloud-eureka-cluster-server7002 | EurekaCluster7002 |
| cloud-eureka-cluster-server7003 | EurekaCluster7003 |



```java
/**
 * 描述 ：
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableEurekaServer
@SpringBootApplication
public class 根据项目名称选择模块 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaCluster7003.class, args);
    }
}
```





### application.yaml





cloud-eureka-cluster-server7001



```yaml
server:
  port: 7001

spring:
  application:
    name: cloud-eureka-cluster-server

eureka:
  instance:
    hostname: erureka1
  client:
    fetch-registry: false  #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    register-with-eureka: false #不需要向eureka注册中心中注册自己
    service-url:
      defaultZone: http://eureka2:7002/eureka/,http://eureka3:7003/eureka/

```



cloud-eureka-cluster-server7002



```yaml
server:
  port: 7002

spring:
  application:
    name: cloud-eureka-cluster-server

eureka:
  instance:
    hostname: erureka2
  client:
    fetch-registry: true  #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    register-with-eureka: false #不需要向eureka注册中心中注册自己
    service-url:
      defaultZone: http://eureka1:7001/eureka/,http://eureka3:7003/eureka/

```



cloud-eureka-cluster-server7003



```yaml
server:
  port: 7003

spring:
  application:
    name: cloud-eureka-cluster-server

eureka:
  instance:
    hostname: erureka3
  client:
    fetch-registry: true  #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    register-with-eureka: false #不需要向eureka注册中心中注册自己
    service-url:
      defaultZone: http://eureka1:7001/eureka/,http://eureka2:7002/eureka/

```



### 测试



+ 访问：http://eureka1:7001/ 或者 http://127.0.0.1:7001/



<img src="./images/image-20220319160640098.png" alt="image-20220319160640098" style="zoom:80%;" />



+ 访问：http://eureka2:7002/ 或者 http://127.0.0.1:7002/



<img src="./images/image-20220319160701666.png" alt="image-20220319160701666" style="zoom:80%;" />![image-20220319160824479](images/image-20220319160824479.png)



+ 访问：http://eureka3:7003/ 或者 http://127.0.0.1:7003/



<img src="./images/image-20220319160824479.png" alt="image-20220319160701666" style="zoom:80%;" />





## 订单提供者注册Eureka集群





### eureka-cluster-provider-payment8001



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-provider</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>eureka-cluster-provider-payment8001</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--热部署插件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```



### 复制代码



复制 `eureka-provider-payment8001`里面的代码和配置文件到 `eureka-cluster-provider-payment8001`

修改启动类名字：`EurekaClusterPaymentAPP8001`

<img src="./images/image-20220319193426168.png" alt="image-20220319193426168" style="zoom:80%;" />



### application.yml



```yaml
server:
  port: 8001

spring:
  application:
    name: eureka-cluster-provider-service
  datasource:
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/test?useSSL=false&allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8
  boot:
    admin:
      client:
        url: http://localhost:5555
        instance:
          prefer-ip: true
#开放端点用于SpringBoot Admin的监控
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    shutdown:
      enabled: true

logging:
  file:
    name: admin-client.log  #配置生成日志文件名称
mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.it.common.entity    # 所有Entity别名类所在包

# eureka 的配置
eureka:
  instance:
    hostname: 127.0.0.1
  client:
    fetch-registry: true  #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    register-with-eureka: true #向eureka服务注册中心中注册自己
    service-url:
      defaultZone: http://eureka1:7001/eureka,http://eureka2:7002/eureka,http://eureka3:7003/eureka
```





### 启动类



```java
/**
 * 描述 ：
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableEurekaClient
@EnableDiscoveryClient //服务注册与发现
@SpringBootApplication
public class EurekaClusterPaymentAPP8001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaClusterPaymentAPP8001.class, args);
    }
}
```





### 测试



http://127.0.0.1:7001/

http://127.0.0.1:7002/

http://127.0.0.1:7003/

<img src="./images/image-20220319193753331.png" alt="image-20220319193753331" style="zoom:80%;" />





## 订单消费者注册到Eureka集群





### eureka-cluster-consumer-order80



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-consumer</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>eureka-cluster-consumer-order80</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--热部署插件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```



### 复制代码



复制 `eureka-consumer-order80`里面的代码和配置文件到 `eureka-cluster-consumer-order80`

修改启动类名字：`EurekaClusterOrderAPP80`



### application.yml



```yaml
server:
  port: 80

spring:
  application:
    name: eureka-cluster-consumer-service

eureka:
  instance:
    hostname: 127.0.0.1
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://eureka1:7001/eureka,http://eureka2:7002/eureka,http://eureka3:7003/eureka

```



### 启动类



```java
/**
 * 描述 ：
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableEurekaClient
@SpringBootApplication
public class EurekaClusterOrderAPP80 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaClusterOrderAPP80.class, args);
    }
}
```



### 测试



http://127.0.0.1:7001/

http://127.0.0.1:7002/

http://127.0.0.1:7003/



<img src="./images/image-20220319194129423.png" alt="image-20220319194129423" style="zoom:80%;" />





## 订单提供者集群搭建



### eureka-cluster-provider-payment8002



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud-provider</artifactId>
        <groupId>com.xht.example.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <packaging>jar</packaging>
    <artifactId>eureka-cluster-provider-payment8002</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--热部署插件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```



### 复制代码



复制 `eureka-cluster-provider-payment8001`里面的代码和配置文件到 `eureka-cluster-provider-payment8002`

修改启动类名字：`EurekaClusterPaymentAPP8002`

<img src="./images/image-20220319194912503.png" alt="image-20220319194912503" style="zoom:80%;" />



### application.yml



就端口改变，其他内容不变，切记**服务名一定要一样！**  **服务名一定要一样！**  **服务名一定要一样！**

```yaml
server:
  port: 8002

spring:
  application:
    name: eureka-cluster-provider-service
  datasource:
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/test?useSSL=false&allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8
  boot:
    admin:
      client:
        url: http://localhost:5555
        instance:
          prefer-ip: true
#开放端点用于SpringBoot Admin的监控
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    shutdown:
      enabled: true

logging:
  file:
    name: admin-client.log  #配置生成日志文件名称
mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.it.common.entity    # 所有Entity别名类所在包

# eureka 的配置
eureka:
  instance:
    hostname: 127.0.0.1
  client:
    fetch-registry: true  #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    register-with-eureka: true #向eureka服务注册中心中注册自己
    service-url:
      defaultZone: http://eureka1:7001/eureka,http://eureka2:7002/eureka,http://eureka3:7003/eureka
```



### 启动类



```java
/**
 * 描述 ：
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableEurekaClient
@EnableDiscoveryClient //服务注册与发现
@SpringBootApplication
public class EurekaClusterPaymentAPP8002 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaClusterPaymentAPP8002.class, args);
    }
}
```



### 测试



<img src="./images/image-20220319195221885.png" alt="image-20220319195221885" style="zoom:80%;" />





## 疑问？



我们已经搭建了两套服务提供者，那么消费者怎么去访问？？？？？

还记得我们设置的服务名称吗？`eureka-cluster-provider-service`

我们可以这样来改：下一节



## 疑问解决



### 修改代码



修改订单消费者服务：`eureka-cluster-consumer-order80`的OrderController



```java
@RestController
public class OrderController
{

    //public static final String PaymentSrv_URL = "http://localhost:8001";
    public static final String PaymentSrv_URL = "http://eureka-cluster-provider-service";

    @Autowired
    private RestTemplate restTemplate;

 	//以下内容均一样不改动，只修改了调用地址
}
```



### 测试-还是失败



postman请求一下：http://127.0.0.1:80/consumer/payment/get/1

<img src="./images/image-20220319200246792.png" alt="image-20220319200246792" style="zoom:80%;" />



出错了





### 错误解决



修改RestTemplateConfig类

```java
@Configuration
public class RestTemplateConfig {
    @Bean
    //使用@LoadBalanced注解赋予RestTemplate负载均衡的能力,他是后面的Ribbon组件的注解，提前用一下后面详解
    @LoadBalanced
    public RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate();
        HttpComponentsClientHttpRequestFactory httpRequestFactory = new HttpComponentsClientHttpRequestFactory();
        httpRequestFactory.setConnectionRequestTimeout(30 * 1000);//请求连接超时
        httpRequestFactory.setConnectTimeout(30 * 3000);//连接超时时间
        httpRequestFactory.setReadTimeout(30 * 3000);//读取超时
        restTemplate.setRequestFactory(httpRequestFactory);
        return restTemplate;
    }
}
```



### 再次测试-成功



http://127.0.0.1:80/consumer/payment/get/1

<img src="./images/image-20220319200554496.png" alt="image-20220319200554496" style="zoom:80%;" />



### 结论(不是重点想看就看不看就不看)



Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能了。O(∩_∩)O





## IP+端口的形式注册服务



当我们的服务集群多了起来，我们就分不清那个服务了，我们可以使用IP+Port来进行显示

<img src="./images/image-20220319202144744.png" alt="image-20220319202144744" style="zoom:80%;" />



+ application.yaml文件



**不需要hostname那个属性**

```java
# eureka 的配置
eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
  #    hostname: 127.0.0.1
```



**可以达到下面的结果**

<img src="./images/image-20220319202700886.png" alt="image-20220319202700886" style="zoom:80%;" />





## 安全认证



### 简介





如果谁都可以访问这个这个页面那么就是不安全的，我们需要为他设置一个密码



### 注册中心添加依赖



我们分别向

+ cloud-eureka-cluster-server7001
+ cloud-eureka-cluster-server7002
+ cloud-eureka-cluster-server7003

里面添加以下依赖：

```xml
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```



### 注册中心修改application.yml



```yaml
server:
  port: 7003 #按项目需求来写

spring:
  application:
    name: cloud-eureka-cluster-server #按项目需求来写
  security:
    user:
      name: root
      password: root
      
eureka:
  instance:
    hostname: erureka3
  client:
    fetch-registry: true  #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    register-with-eureka: false #不需要向eureka注册中心中注册自己
    service-url:
      defaultZone: http://root:root@eureka1:7001/eureka/,http://root:root@eureka2:7002/eureka/ #按项目需求来写格式按我的写

```



### 服务的提供者和发现者配置文件



```java
eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
       defaultZone: http://root:root@eureka1:7001/eureka,http://root:root@eureka2:7002/eureka,http://root:root@eureka3:7003/eureka
```





### 过滤CSRF



 Eureka会自动配置CSRF防御机制,spring security认为post,put and delete http methods 都是有风险的,如果这些method发送过程中没有带上CSRF token,会被直接拦截并返回403 forbidden

 首先注册中心配置一个@EnableWebSecurity配置类,继承WebSecurityConfigurerAdapter,然后重写configure方法



### 过滤CSRF方案一



使CSRF忽略/eureka/**的所有请求

```java
package com.it.config;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * 描述 ：
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    /**
     * 方案一 过滤指定路径
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //这句为了访问eureka控制台和/actuator时能做安全控制
        super.configure(http);
        //忽略指定路径的所有请求
        http.csrf().ignoringAntMatchers("/eureka/**");
    }
}
```



<img src="./images/image-20220319214510644.png" alt="image-20220319214510644" style="zoom:80%;" />





### 过滤CSRF方案二



 保持密码验证的同时禁用CSRF的防御机制



```java
package com.it.config;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
/**
 * 描述 ：
 *
 * @author : 小糊涂
 * @version : 1.0
 **/
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    /**
     * 方案二 保持密码验证的同时禁用CSRF防御机制
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //如果直接用disable()会把安全验证也警用掉
        http.csrf().disable().authorizeRequests()
                .anyRequest()
                .authenticated()
                .and()
                .httpBasic();
    }
}
```



<img src="./images/image-20220319214333609.png" alt="image-20220319214333609" style="zoom:80%;" />



### 过滤CSRF登录成功



<img src="./images/image-20220319214550266.png" alt="image-20220319214550266" style="zoom:80%;" />





## 服务提供的接口





使用**postMan**来调用测试

| Path                                                         | 描述                       |
| ------------------------------------------------------------ | -------------------------- |
| POST /eureka/apps/{appId}                                    | 服务注册：注册新的应用实例 |
| DELETE /eureka/apps/{appId}/{instanceId}                     | 服务注销：注销某个实例     |
| PUT /eureka/apps/{appId}/{instanceId}                        | 服务续约：应用实例发送心跳 |
| GET /eureka/apps                                             | 查询所有实例               |
| GET /eureka/apps/{appId}                                     | 查询指定appId的实例        |
| GET /eureka/apps/{appId}/{instanceId}                        | 查询某个appId和instanceId  |
| GET /eureka/instanceId/{instanceId}                          | 根据指定instanceId查询     |
| PUT /eureka/apps/{appId}/{instanceId}/status?value=OUT_OF_SERVICE | 暂停应用实例               |
| DELETE /eureka/apps/{appId}/{instanceId}/status?value=UP     | 恢复应用实例               |
| PUT /eureka/apps/{appId}/{instanceId}/metadata?key=value     | 更新元数据                 |
| GET /eureka/v2/vips/{vipAddress}                             | 根据vip地址查询            |
| GET /eureka/v2/vips/{svipAddress}                            | 根据svip地址查询           |







## 常用配置



### 服务端



```java
org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean
```

| 参数名称                                                     | 说明                                                         | 默认值 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
| **eureka.server.enable-self-preservation**                   | 启用自我保护机制，默认为true                                 | true   |
| **eureka.server.eviction-interval-timer-in-ms**              | 清除无效服务实例的时间间隔（ms），默认1分钟                  | 60000  |
| **eureka.server.delta-retention-timer-interval-in-ms**       | 清理无效增量信息的时间间隔（ms），默认30秒                   | 30000  |
| **eureka.server.disable-delta**                              | 禁用增量获取服务实例信息                                     | false  |
| **eureka.server.log-identity-headers**                       | 是否记录登录日志                                             | true   |
| **eureka.server.rate-limiter-burst-size**                    | 限流大小                                                     | 10     |
| **eureka.server.rate-limiter-enabled**                       | 是否启用限流                                                 | false  |
| **eureka.server.rate-limiter-full-fetch-average-rate**       | 平均请求速率                                                 | 100    |
| **eureka.server.rate-limiter-throttle-standard-clients**     | 是否对标准客户端进行限流                                     | false  |
| **eureka.server.rate-limiter-registry-fetch-average-rate**   | 服务注册与拉取的平均速率                                     | 500    |
| **eureka.server.rate-limiter-privileged-clients**            | 信任的客户端列表                                             |        |
| **eureka.server.renewal-percent-threshold**                  | 15分钟内续约服务的比例小于0.85，则开启自我保护机制，再此期间不会清除已注册的任何服务（即便是无效服务） | 0.85   |
| **eureka.server.renewal-threshold-update-interval-ms**       | 更新续约阈值的间隔（分钟），默认15分钟                       | 15     |
| **eureka.server.response-cache-auto-expiration-in-seconds**  | 注册信息缓存有效时长（s），默认180秒                         | 180    |
| **eureka.server.response-cache-update-interval-ms**          | 注册信息缓存更新间隔（s），默认30秒                          | 30     |
| **eureka.server.retention-time-in-m-s-in-delta-queue**       | 保留增量信息时长（分钟），默认3分钟                          | 3      |
| **eureka.server.sync-when-timestamp-differs**                | 当时间戳不一致时，是否进行同步                               | true   |
| **eureka.server.use-read-only-response-cache**               | 是否使用只读缓存策略                                         | true   |
| 自定义工具设置                                               |                                                              |        |
| **eureka.server.json-codec-name**                            | Json编解码器名称                                             |        |
| **eureka.server.property-resolver**                          | 属性解析器名称                                               |        |
| **eureka.server.xml-codec-name**                             | Xml编解码器名称                                              |        |
| Eureka Server 集群配置                                       |                                                              |        |
| **eureka.server.enable-replicated-request-compression**      | 复制数据请求时，数据是否压缩                                 | false  |
| **eureka.server.batch-replication**                          | 节点之间数据复制是否采用批处理                               | false  |
| **eureka.server.max-elements-in-peer-replication-pool**      | 备份池最大备份事件数量，默认1000                             | 1000   |
| **eureka.server.max-elements-in-status-replication-pool**    | 状态备份池最大备份事件数量，默认1000                         | 1000   |
| **eureka.server.max-idle-thread-age-in-minutes-for-peer-replication** | 节点之间信息同步线程最大空闲时间（分钟）                     | 15     |
| **eureka.server.max-idle-thread-in-minutes-age-for-status-replication** | 节点之间状态同步线程最大空闲时间（分钟）                     | 10     |
| **eureka.server.max-threads-for-peer-replication**           | 节点之间信息同步最大线程数量                                 | 20     |
| **eureka.server.max-threads-for-status-replication**         | 节点之间状态同步最大线程数量                                 | 1      |
| **eureka.server.max-time-for-replication**                   | 节点之间信息复制最大通信时长（ms）                           | 30000  |
| **eureka.server.min-available-instances-for-peer-replication** | 集群中服务实例最小数量，-1 表示单节点                        | -1     |
| **eureka.server.min-threads-for-peer-replication**           | 节点之间信息复制最小线程数量                                 | 5      |
| **eureka.server.min-threads-for-status-replication**         | 节点之间信息状态同步最小线程数量                             | 1      |
| **eureka.server.number-of-replication-retries**              | 节点之间数据复制时，可重试次数                               | 5      |
| **eureka.server.peer-eureka-nodes-update-interval-ms**       | 节点更新数据间隔时长（分钟）                                 | 10     |
| **eureka.server.peer-eureka-status-refresh-time-interval-ms** | 节点之间状态刷新间隔时长（ms）                               | 30000  |
| **eureka.server.peer-node-connect-timeout-ms**               | 节点之间连接超时时长（ms）                                   | 200    |
| **eureka.server.peer-node-connection-idle-timeout-seconds**  | 节点之间连接后，空闲时长（s）                                | 30     |
| **eureka.server.peer-node-read-timeout-ms**                  | 几点之间数据读取超时时间（ms）                               | 200    |
| **eureka.server.peer-node-total-connections**                | 集群中节点连接总数                                           | 1000   |
| **eureka.server.peer-node-total-connections-per-host**       | 节点之间连接，单机最大连接数量                               | 500    |
| **eureka.server.registry-sync-retries**                      | 节点启动时，尝试获取注册信息的次数                           | 500    |
| **eureka.server.registry-sync-retry-wait-ms**                | 节点启动时，尝试获取注册信息的间隔时长（ms）                 | 30000  |
| **eureka.server.wait-time-in-ms-when-sync-empty**            | 在Eureka服务器获取不到集群里对等服务器上的实例时，需要等待的时间（分钟） | 5      |



### 服务实例



```java
org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean
```

| 参数名称                                                     | 说明                                                         | 默认值           |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- |
| **eureka.instance.appname**                                  | 注册到注册中心的应用名称                                     | unknown          |
| **eureka.instance.a-s-g-name**                               | 注册到注册中心的应用所属分组名称（AWS服务器）                | null             |
| **eureka.instance.app-group-name**                           | 注册到注册中心的应用所属分组名称                             | null             |
| **eureka.instance.data-center-info**                         | 指定服务实例所属数据中心                                     |                  |
| **eureka.instance.instance-enabled-onit**                    | 指示是否应在eureka注册后立即启用实例以获取流量               | false            |
| **eureka.instance.non-secure-port**                          | http通信端口                                                 | 80               |
| **eureka.instance.non-secure-port-enabled**                  | 是否启用HTTP通信端口                                         | ture             |
| **eureka.instance.secure-port**                              | HTTPS通信端口                                                | 443              |
| **eureka.instance.secure-port-enabled**                      | 是否启用HTTPS通信端口                                        | false            |
| **eureka.instance.secure-virtual-host-name**                 | 服务实例安全主机名称（HTTPS）                                | unknown          |
| **eureka.instance.virtual-host-name**                        | 该服务实例非安全注解名称（HTTP）                             | unknown          |
| **eureka.instance.secure-health-check-url**                  | 该服务实例安全健康检查地址（URL），绝对地址                  |                  |
| **eureka.instance.lease-renewal-interval-in-seconds**        | 该服务实例向注册中心发送心跳间隔（s）                        | 30               |
| **eureka.instance.lease-expiration-duration-in-seconds**     | 指示eureka服务器在删除此实例之前收到最后一次心跳之后等待的时间（s） | 90               |
| **eureka.instance.metadata-map.\***                          |                                                              |                  |
| **eureka.instance.ip-address**                               | 该服务实例的IP地址                                           | null             |
| **eureka.instance.prefer-ip-address**                        | 是否优先使用服务实例的IP地址，相较于hostname                 | false            |
| **eureka.instance.status-page-url**                          | 该服务实例的状态检查地址（url），绝对地址                    | null             |
| **eureka.instance.status-page-url-path**                     | 该服务实例的状态检查地址，相对地址                           | /actuator/info   |
| **eureka.instance.home-page-url**                            | 该服务实例的主页地址（url），绝对地址                        |                  |
| **eureka.instance.home-page-url-path**                       | 该服务实例的主页地址，相对地址                               | /                |
| **eureka.instance.health-check-url**                         | 该服务实例的健康检查地址（url），绝对地址                    | null             |
| **eureka.instance.health-check-url-path**                    | 该服务实例的健康检查地址，相对地址                           | /actuator/health |
| **eureka.instance.instance-id**                              | 该服务实例在注册中心的唯一实例ID                             |                  |
| **eureka.instance.hostname**                                 | 该服务实例所在主机名                                         |                  |
| **eureka.instance.namespace**                                | 获取用于查找属性的命名空间。 在Spring Cloud中被忽略。        | eureka           |
| **eureka.instance.environment**                              | 该服务实例环境配置                                           |                  |
| **eureka.instance.default-address-resolution-order**         | 默认地址解析顺序                                             |                  |
| **eureka.instance.initial-status**                           | 该服务实例注册到Eureka Server 的初始状态                     | up               |
| **eureka.instance.registry.default-open-for-traffic-count**  | 【Eureka Server 端属性】默认开启通信的数量                   | 1                |
| **eureka.instance.registry.expected-number-of-renews-per-min** | 【Eureka Server 端属性】每分钟续约次数                       | 1                |



### 客户端



```java
org.springframework.cloud.netflix.eureka.EurekaClientConfigBean
```

| 参数                                                         | 说明                                                         | 默认值    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |
| **eureka.client.enabled**                                    | 用于指示Eureka客户端已启用的标志                             | true      |
| **eureka.client.registry-fetch-interval-seconds**            | 指示从eureka服务器获取注册表信息的频率（s）                  | 30        |
| **eureka.client.instance-info-replication-interval-seconds** | 更新实例信息的变化到Eureka服务端的间隔时间，（s）            | 30        |
| **eureka.client.initial-instance-info-replication-interval-seconds** | 初始化实例信息到Eureka服务端的间隔时间，（s）                | 40        |
| **eureka.client.eureka-service-url-poll-interval-seconds**   | 询问Eureka Server信息变化的时间间隔（s），默认为300秒        | 300       |
| **eureka.client.eureka-server-read-timeout-seconds**         | 读取Eureka Server 超时时间（s），默认8秒                     | 8         |
| **eureka.client.eureka-server-connect-timeout-seconds**      | 连接Eureka Server 超时时间（s），默认5秒                     | 5         |
| **eureka.client.eureka-server-total-connections**            | 获取从eureka客户端到所有eureka服务器的连接总数,默认200个     | 200       |
| **eureka.client.eureka-server-total-connections-per-host**   | 获取从eureka客户端到eureka服务器主机允许的连接总数，默认50个 | 50        |
| **eureka.client.eureka-connection-idle-timeout-seconds**     | 连接到 Eureka Server 空闲连接的超时时间（s），默认30         | 30        |
| **eureka.client.registry-refresh-single-vip-address**        | 指示客户端是否仅对单个VIP的注册表信息感兴趣，默认为null      | null      |
| **eureka.client.heartbeat-executor-thread-pool-size**        | 心跳保持线程池初始化线程数，默认2个                          | 2         |
| **eureka.client.heartbeat-executor-exponential-back-off-bound** | 心跳超时重试延迟时间的最大乘数值，默认10                     | 10        |
| **eureka.client.serviceUrl.defaultZone**                     | 可用区域映射到与eureka服务器通信的完全限定URL列表。每个值可以是单个URL或逗号分隔的备用位置列表。(http://${eureka.instance.hostname}:${server.port}/eureka/) |           |
| **eureka.client.use-dns-for-fetching-service-urls**          | 指示eureka客户端是否应使用DNS机制来获取要与之通信的eureka服务器列表。当DNS名称更新为具有其他服务器时，eureka客户端轮询eurekaServiceUrlPollIntervalSeconds中指定的信息后立即使用该信息。 | false     |
| **eureka.client.register-with-eureka**                       | 指示此实例是否应将其信息注册到eureka服务器以供其他服务发现，默认为false | True      |
| **eureka.client.prefer-same-zone-eureka**                    | 实例是否使用同一zone里的eureka服务器，默认为true，理想状态下，eureka客户端与服务端是在同一zone下 | true      |
| **eureka.client.log-delta-diff**                             | 是否记录eureka服务器和客户端之间在注册表的信息方面的差异，默认为false | false     |
| **eureka.client.disable-delta**                              | 指示eureka客户端是否禁用增量提取                             | false     |
| **eureka.client.fetch-remote-regions-registry**              | 逗号分隔的区域列表，提取eureka注册表信息                     |           |
| **eureka.client.on-demand-update-status-change**             | 客户端的状态更新到远程服务器上，默认为true                   | true      |
| **eureka.client.allow-redirects**                            | 指示服务器是否可以将客户端请求重定向到备份服务器/集群。如果设置为false，则服务器将直接处理请求。如果设置为true，则可以将HTTP重定向发送到具有新服务器位置的客户端。 | false     |
| **eureka.client.availability-zones.\***                      | 获取此实例所在区域的可用区域列表（在AWS数据中心中使用）。更改在运行时在registryFetchIntervalSeconds指定的下一个注册表获取周期生效。 |           |
| **eureka.client.backup-registry-impl**                       | 获取实现BackupRegistry的实现的名称，该实现仅在eureka客户端启动时第一次作为后备选项获取注册表信息。 对于需要额外的注册表信息弹性的应用程序，可能需要这样做，否则它将无法运行。 |           |
| **eureka.client.cache-refresh-executor-exponential-back-off-bound** | 在发生一系列超时的情况下，它是重试延迟的最大乘数值。         | 10        |
| **eureka.client.cache-refresh-executor-thread-pool-size**    | 缓存刷新线程池初始化线程数量                                 | 2         |
| **eureka.client.client-data-accept**                         | 客户端数据接收的名称                                         | full      |
| **eureka.client.decoder-name**                               | 解码器名称                                                   |           |
| **eureka.client.dollar-replacement**                         | eureka服务器序列化/反序列化的信息中获取“$”符号的替换字符串。默认为“_-” |           |
| **eureka.client.encoder-name**                               | 编码器名称                                                   |           |
| **eureka.client.escape-char-replacement**                    | eureka服务器序列化/反序列化的信息中获取“_”符号的的替换字符串。默认为“__“ |           |
| **eureka.client.eureka-server-d-n-s-name**                   | 获取要查询的DNS名称来获得eureka服务器，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为null | null      |
| **eureka.client.eureka-server-port**                         | 获取eureka服务器的端口，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为null | null      |
| **eureka.client.eureka-server-u-r-l-context**                | 表示eureka注册中心的路径，如果配置为eureka，则为http://ip:port/eureka/，在eureka的配置文件中加入此配置表示eureka作为客户端向注册中心注册，从而构成eureka集群。此配置只有在eureka服务器ip地址列表是在DNS中才会用到，默认为null | null      |
| **eureka.client.fetch-registry**                             | 客户端是否获取eureka服务器注册表上的注册信息，默认为true     | true      |
| **eureka.client.filter-only-up-instances**                   | 是否过滤掉非up实例，默认为true                               | true      |
| **eureka.client.g-zip-content**                              | 当服务端支持压缩的情况下，是否支持从服务端获取的信息进行压缩。默认为true |           |
| **eureka.client.property-resolver**                          | 属性解析器                                                   |           |
| **eureka.client.proxy-host**                                 | 获取eureka server 的代理主机名                               | null      |
| **eureka.client.proxy-password**                             | 获取eureka server 的代理主机密码                             | null      |
| **eureka.client.proxy-port**                                 | 获取eureka server 的代理主机端口                             | null      |
| **eureka.client.proxy-user-name**                            | 获取eureka server 的代理用户名                               | null      |
| **eureka.client.region**                                     | 获取此实例所在的区域（在AWS数据中心中使用）。                | us-east-1 |
| **eureka.client.should-enforce-registration-at-init**        | client 在初始化阶段是否强行注册到注册中心                    | false     |
| **eureka.client.should-unregister-on-shutdown**              | client在shutdown情况下，是否显示从注册中心注销               | true      |



## 总结



1.服务实例启动，会将自己的信息注册到Eureka中，这叫服务注册

2.Eureka会保存服务实例名称和实例地址列表的映射关系

3.消费者根据服务名称，拉去实例列表，这叫服务发现或者服务拉取

4.消费者会根据负载均衡算法从实例列表中选取一个实例地址

5.提供者会每30秒一次向Eureka报告自己的状态，这叫心跳续约

6.当超过一定时间没有发送心跳后，Eureka会任务微服务实例故障，将其从实例列表中剔除

7.一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端









## 集群启动时错误（了解）





出现下列错误不用管

<img src="./images/image-20220323174458524.png" alt="image-20220323174458524" style="zoom:80%;" />




